{"version":3,"sources":["renderer/pages/dashboard/component/terminal/util/LocalEchoController.js","renderer/pages/dashboard/component/terminal/util/Utils.js","renderer/pages/dashboard/component/terminal/util/HistoryController.js"],"names":["LocalEchoController","term","options","arguments","length","undefined","Object","_Users_mac_Documents_cxq_web_a_plan_node_modules_babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_0__","this","_handleTermData","handleTermData","bind","_handleTermResize","handleTermResize","history","HistoryController","historySize","maxAutocompleteEntries","_autocompleteHandlers","_active","_input","_cursor","_activePrompt","_activeCharPrompt","_termSize","cols","rows","attach","off","on","fn","_len","args","Array","_key","push","idx","findIndex","e","splice","prompt","_this","continuationPrompt","Promise","resolve","reject","write","promptString","replace","_this2","reason","message","print","items","padding","println","itemWidth","reduce","width","item","Math","max","wideCols","floor","wideRows","ceil","i","row","rowStr","col","repeat","input","offset","applyPromptsString","substr","currentPrompt","allRows","console","log","promptCursor","applyPromptOffset","moveRows","newInput","clearInput","newPrompt","applyPrompts","callback","_this3","cursor","setCursor","resume","setInput","ret","then","newCursor","inputWithPrompt","prevPromptOffset","countLines","_offsetToColRow","offsetToColRow","prevCol","prevRow","newPromptOffset","_offsetToColRow2","newCol","newRow","dir","num","min","backspace","data","_this4","charCodeAt","normData","from","forEach","c","handleData","_this5","ofs","ord","value","getPrevious","getNext","handleCursorMove","handleCursorErase","closestLeftBoundary","closestRightBoundary","isIncompleteInput","handleCursorInsert","handleReadComplete","inputFragment","hasTailingSpace","hasTailingWhitespace","candidates","collectAutocompleteCandidates","sort","lastToken","getLastToken","printAndRestartPrompt","printWide","readChar","concat","yn","rewind","clear","wordBoundaries","match","leftSide","words","rx","exec","index","found","reverse","find","x","maxCols","charAt","trim","split","pop","endsWith","parse","callbacks","tokens","expr","_ref","apply","_Users_mac_Documents_cxq_web_a_plan_node_modules_babel_runtime_helpers_esm_toConsumableArray__WEBPACK_IMPORTED_MODULE_0__","error","filter","txt","startsWith","size","entries","_Users_mac_Documents_cxq_web_a_plan_node_modules_babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_1__","key","entry"],"mappings":"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","file":"static/js/dashboard-component-terminal-util-LocalEchoController.c1ec0f32.chunk.js","sourcesContent":["import { HistoryController } from \"./HistoryController\";\nimport {\n  closestLeftBoundary,\n  closestRightBoundary,\n  collectAutocompleteCandidates,\n  countLines,\n  getLastToken,\n  hasTailingWhitespace,\n  isIncompleteInput,\n  offsetToColRow\n} from \"./Utils\";\n\n/**\n * A local terminal controller is responsible for displaying messages\n * and handling local echo for the terminal.\n *\n * Local echo supports most of bash-like input primitives. Namely:\n * - Arrow navigation on the input\n * - Alt-arrow for word-boundary navigation\n * - Alt-backspace for word-boundary deletion\n * - Multi-line input for incomplete commands\n * - Auto-complete hooks\n */\nexport default class LocalEchoController {\n  constructor(term, options = {}) {\n    this.term = term;\n    this._handleTermData = this.handleTermData.bind(this);\n    this._handleTermResize = this.handleTermResize.bind(this)\n    \n    this.history = new HistoryController(options.historySize || 10);\n    this.maxAutocompleteEntries = options.maxAutocompleteEntries || 100;\n\n    this._autocompleteHandlers = [];\n    this._active = false;\n    this._input = \"\";\n    this._cursor = 0;\n    this._activePrompt = null;\n    this._activeCharPrompt = null;\n    this._termSize = {\n      cols: this.term.cols,\n      rows: this.term.rows\n    };\n    \n    this.attach()\n  }\n\n  /////////////////////////////////////////////////////////////////////////////\n  // User-Facing API\n  /////////////////////////////////////////////////////////////////////////////\n  \n  /**\n   *  Detach the controller from the terminal\n   */\n  detach() {\n    this.term.off(\"data\", this._handleTermData);\n    this.term.off(\"resize\", this._handleTermResize);\n  }\n  \n  /**\n   * Attach controller to the terminal, handling events\n   */\n  attach() {\n    this.term.on(\"data\", this._handleTermData);\n    this.term.on(\"resize\", this._handleTermResize);\n  }\n\n  /**\n   * Register a handler that will be called to satisfy auto-completion\n   */\n  addAutocompleteHandler(fn, ...args) {\n    this._autocompleteHandlers.push({\n      fn,\n      args\n    });\n  }\n\n  /**\n   * Remove a previously registered auto-complete handler\n   */\n  removeAutocompleteHandler(fn) {\n    const idx = this._autocompleteHandlers.findIndex(e => e.fn === fn);\n    if (idx === -1) return;\n\n    this._autocompleteHandlers.splice(idx, 1);\n  }\n\n  /**\n   * Return a promise that will resolve when the user has completed\n   * typing a single line\n   */\n  read(prompt, continuationPrompt = \"> \") {\n    return new Promise((resolve, reject) => {\n      this.term.write(prompt);\n      this._activePrompt = {\n        prompt: prompt,\n        promptString: prompt ?  prompt.replace(/(\\x1b.*?[m])|(\\x1b.*$)/g, '').replace(/\\n/,'').replace(/\\r/,'') : '',\n        continuationPrompt,\n        resolve,\n        reject\n      };\n\n      this._input = \"\";\n      this._cursor = 0;\n      this._active = true;\n    });\n  }\n\n  /**\n   * Return a promise that will be resolved when the user types a single\n   * character.\n   *\n   * This can be active in addition to `.read()` and will be resolved in\n   * priority before it.\n   */\n  readChar(prompt) {\n    return new Promise((resolve, reject) => {\n      this.term.write(prompt);\n      this._activeCharPrompt = {\n        prompt,\n        resolve,\n        reject\n      };\n    });\n  }\n\n  /**\n   * Abort a pending read operation\n   */\n  abortRead(reason = \"aborted\") {\n    if (this._activePrompt != null || this._activeCharPrompt != null) {\n      this.term.write(\"\\r\\n\");\n    }\n    if (this._activePrompt != null) {\n      this._activePrompt.reject(reason);\n      this._activePrompt = null;\n    }\n    if (this._activeCharPrompt != null) {\n      this._activeCharPrompt.reject(reason);\n      this._activeCharPrompt = null;\n    }\n    this._active = false;\n  }\n\n  /**\n   * Prints a message and changes line\n   */\n  println(message) {\n    this.print(message + \"\\n\");\n  }\n\n  /**\n   * Prints a message and properly handles new-lines\n   */\n  print(message) {\n    this.term.write(message);\n  }\n\n  /**\n   * Prints a list of items using a wide-format\n   */\n  printWide(items, padding = 2) {\n    if (items.length == 0) return this.println(\"\");\n\n    // Compute item sizes and matrix row/cols\n    const itemWidth =\n      items.reduce((width, item) => Math.max(width, item.length), 0) + padding;\n    const wideCols = Math.floor(this._termSize.cols / itemWidth);\n    const wideRows = Math.ceil(items.length / wideCols);\n\n    // Print matrix\n    let i = 0;\n    for (let row = 0; row < wideRows; ++row) {\n      let rowStr = \"\";\n\n      // Prepare columns\n      for (let col = 0; col < wideCols; ++col) {\n        if (i < items.length) {\n          let item = items[i++];\n          item += \" \".repeat(itemWidth - item.length);\n          rowStr += item;\n        }\n      }\n      this.println(rowStr);\n    }\n  }\n\n  /////////////////////////////////////////////////////////////////////////////\n  // Internal API\n  /////////////////////////////////////////////////////////////////////////////\n\n  /**\n   * Apply prompts to the given input\n   */\n  applyPrompts(input) {\n    const prompt = (this._activePrompt || {}).prompt || \"\";\n    const continuationPrompt =\n      (this._activePrompt || {}).continuationPrompt || \"\";\n\n    return prompt + input.replace(/\\n/g, \"\\n\" + continuationPrompt);\n  }\n  applyPromptsString(input) {\n    const prompt = (this._activePrompt || {}).promptString || \"\";\n    const continuationPrompt =\n      (this._activePrompt || {}).continuationPrompt || \"\";\n\n    return prompt + input.replace(/\\n/g, \"\\n\" + continuationPrompt);\n  }\n  /**\n   * Advances the `offset` as required in order to accompany the prompt\n   * additions to the input.\n   */\n  applyPromptOffset(input, offset) {\n    const newInput = this.applyPromptsString(input.substr(0, offset));\n    return newInput.length;\n  }\n\n  /**\n   * Clears the current prompt\n   *\n   * This function will erase all the lines that display the current prompt\n   * and move the cursor in the beginning of the first line of the prompt.\n   */\n  clearInput() {\n    const currentPrompt = this.applyPromptsString(this._input);\n\n    // Get the overall number of lines to clear\n    // const allRows = countLines(currentPrompt, this._termSize.cols);\n    let allRows = Math.floor(currentPrompt.length/this._termSize.cols)\n    if (currentPrompt.length%this._termSize.cols > 0) {\n      allRows += 1;\n    }\n    console.log('allRows', allRows)\n    // Get the line we are currently in\n    const promptCursor = this.applyPromptOffset(this._input, this._cursor);\n    let row = Math.floor(promptCursor/this._termSize.cols)\n    let col = promptCursor%this._termSize.cols;\n    if (col) {\n      row += 1;\n    }\n\n    // First move on the last line\n    const moveRows = allRows - row - 1;\n    for (var i = 0; i < moveRows; ++i) this.term.write(\"\\x1B[E\");\n\n    // Clear current input line(s)\n    this.term.write(\"\\r\\x1B[K\");\n    for (var i = 1; i < allRows; ++i) this.term.write(\"\\x1B[F\\x1B[K\");\n  }\n\n  /**\n   * Replace input with the new input given\n   *\n   * This function clears all the lines that the current input occupies and\n   * then replaces them with the new input.\n   */\n  setInput(newInput, clearInput = true) {\n    // Clear current input\n    if (clearInput) this.clearInput();\n\n    // Write the new input lines, including the current prompt\n    const newPrompt = this.applyPrompts(newInput);\n    this.term.write(newPrompt);\n\n    // Trim cursor overflow\n    // if (this._cursor > newInput.length) {\n    //   this._cursor = newInput.length;\n    // }\n\n    // // Move the cursor to the appropriate row/col\n    // const newCursor = this.applyPromptOffset(newInput, this._cursor);\n    // const newLines = countLines(newPrompt, this._termSize.cols);\n    // const { col, row } = offsetToColRow(\n    //   newPrompt,\n    //   newCursor,\n    //   this._termSize.cols\n    // );\n    // const moveUpRows = newLines - row - 1;\n\n    // this.term.write(\"\\r\");\n    // for (var i = 0; i < moveUpRows; ++i) this.term.write(\"\\x1B[F\");\n    // for (var i = 0; i < col; ++i) this.term.write(\"\\x1B[C\");\n\n    // Replace input\n    this._input = newInput;\n  }\n\n  /**\n   * This function completes the current input, calls the given callback\n   * and then re-displays the prompt.\n   */\n  printAndRestartPrompt(callback) {\n    const cursor = this._cursor;\n\n    // Complete input\n    this.setCursor(this._input.length);\n    this.term.write(\"\\r\\n\");\n\n    // Prepare a function that will resume prompt\n    const resume = () => {\n      this._cursor = cursor;\n      this.setInput(this._input);\n    };\n\n    // Call the given callback to echo something, and if there is a promise\n    // returned, wait for the resolution before resuming prompt.\n    const ret = callback();\n    if (ret == null) {\n      resume();\n    } else {\n      ret.then(resume);\n    }\n  }\n\n  /**\n   * Set the new cursor position, as an offset on the input string\n   *\n   * This function:\n   * - Calculates the previous and current\n   */\n  setCursor(newCursor) {\n    if (newCursor < 0) newCursor = 0;\n    if (newCursor > this._input.length) newCursor = this._input.length;\n\n    // Apply prompt formatting to get the visual status of the display\n    const inputWithPrompt = this.applyPrompts(this._input);\n    const inputLines = countLines(inputWithPrompt, this._termSize.cols);\n\n    // Estimate previous cursor position\n    const prevPromptOffset = this.applyPromptOffset(this._input, this._cursor);\n    const { col: prevCol, row: prevRow } = offsetToColRow(\n      inputWithPrompt,\n      prevPromptOffset,\n      this._termSize.cols\n    );\n\n    // Estimate next cursor position\n    const newPromptOffset = this.applyPromptOffset(this._input, newCursor);\n    const { col: newCol, row: newRow } = offsetToColRow(\n      inputWithPrompt,\n      newPromptOffset,\n      this._termSize.cols\n    );\n\n    // Adjust vertically\n    if (newRow > prevRow) {\n      for (let i = prevRow; i < newRow; ++i) this.term.write(\"\\x1B[B\");\n    } else {\n      for (let i = newRow; i < prevRow; ++i) this.term.write(\"\\x1B[A\");\n    }\n\n    // Adjust horizontally\n    if (newCol > prevCol) {\n      for (let i = prevCol; i < newCol; ++i) this.term.write(\"\\x1B[C\");\n    } else {\n      for (let i = newCol; i < prevCol; ++i) this.term.write(\"\\x1B[D\");\n    }\n\n    // Set new offset\n    this._cursor = newCursor;\n  }\n\n  /**\n   * Move cursor at given direction\n   */\n  handleCursorMove(dir) {\n    if (dir > 0) {\n      const num = Math.min(dir, this._input.length - this._cursor);\n      this.setCursor(this._cursor + num);\n    } else if (dir < 0) {\n      const num = Math.max(dir, -this._cursor);\n      this.setCursor(this._cursor + num);\n    }\n  }\n\n  /**\n   * Erase a character at cursor location\n   */\n  handleCursorErase(backspace) {\n    const { _cursor, _input } = this;\n    if (backspace) {\n      if (_cursor <= 0) return;\n      const newInput = _input.substr(0, _cursor - 1) + _input.substr(_cursor);\n      this.clearInput();\n      this._cursor -= 1;\n      this.setInput(newInput, false);\n    } else {\n      const newInput = _input.substr(0, _cursor) + _input.substr(_cursor + 1);\n      this.setInput(newInput);\n    }\n  }\n\n  /**\n   * Insert character at cursor location\n   */\n  handleCursorInsert(data) {\n    const { _cursor, _input } = this;\n    const newInput = _input.substr(0, _cursor) + data + _input.substr(_cursor);\n    this._cursor += data.length;\n    this.setInput(newInput);\n  }\n\n  /**\n   * Handle input completion\n   */\n  handleReadComplete() {\n    if (this.history) {\n      this.history.push(this._input);\n    }\n    if (this._activePrompt) {\n      this._activePrompt.resolve(this._input);\n      this._activePrompt = null;\n    }\n    this.term.write(\"\\r\\n\");\n    this._active = false;\n  }\n\n  /**\n   * Handle terminal resize\n   *\n   * This function clears the prompt using the previous configuration,\n   * updates the cached terminal size information and then re-renders the\n   * input. This leads (most of the times) into a better formatted input.\n   */\n  handleTermResize(data) {\n    const { rows, cols } = data;\n    this.clearInput();\n    this._termSize = { cols, rows };\n    this.setInput(this._input, false);\n  }\n\n  /**\n   * Handle terminal input\n   */\n  handleTermData(data) {\n    if (!this._active) return;\n\n    // If we have an active character prompt, satisfy it in priority\n    if (this._activeCharPrompt != null) {\n      this._activeCharPrompt.resolve(data);\n      this._activeCharPrompt = null;\n      this.term.write(\"\\r\\n\");\n      return;\n    }\n\n    // If this looks like a pasted input, expand it\n    if (data.length > 3 && data.charCodeAt(0) !== 0x1b) {\n      const normData = data.replace(/[\\r\\n]+/g, \"\\r\");\n      Array.from(normData).forEach(c => this.handleData(c));\n    } else {\n      this.handleData(data);\n    }\n  }\n\n  /**\n   * Handle a single piece of information from the terminal.\n   */\n  handleData(data) {\n    if (!this._active) return;\n    const ord = data.charCodeAt(0);\n    let ofs;\n\n    // Handle ANSI escape sequences\n    if (ord === 0x1b) {\n      switch (data.substr(1)) {\n        case \"[A\": // Up arrow\n          if (this.history) {\n            let value = this.history.getPrevious();\n            if (value) {\n              this.setInput(value);\n              this.setCursor(value.length);\n            }\n          }\n          break;\n\n        case \"[B\": // Down arrow\n          if (this.history) {\n            let value = this.history.getNext();\n            if (!value) value = \"\";\n            this.setInput(value);\n            this.setCursor(value.length);\n          }\n          break;\n\n        case \"[D\": // Left Arrow\n          this.handleCursorMove(-1);\n          break;\n\n        case \"[C\": // Right Arrow\n          this.handleCursorMove(1);\n          break;\n\n        case \"[3~\": // Delete\n          this.handleCursorErase(false);\n          break;\n\n        case \"[F\": // End\n          this.setCursor(this._input.length);\n          break;\n\n        case \"[H\": // Home\n          this.setCursor(0);\n          break;\n\n        case \"b\": // ALT + LEFT\n          ofs = closestLeftBoundary(this._input, this._cursor);\n          if (ofs != null) this.setCursor(ofs);\n          break;\n\n        case \"f\": // ALT + RIGHT\n          ofs = closestRightBoundary(this._input, this._cursor);\n          if (ofs != null) this.setCursor(ofs);\n          break;\n\n        case \"\\x7F\": // CTRL + BACKSPACE\n          ofs = closestLeftBoundary(this._input, this._cursor);\n          if (ofs != null) {\n            this.setInput(\n              this._input.substr(0, ofs) + this._input.substr(this._cursor)\n            );\n            this.setCursor(ofs);\n          }\n          break;\n      }\n\n      // Handle special characters\n    } else if (ord < 32 || ord === 0x7f) {\n      switch (data) {\n        case \"\\r\": // ENTER\n          if (isIncompleteInput(this._input)) {\n            this.handleCursorInsert(\"\\n\");\n          } else {\n            this.handleReadComplete();\n          }\n          break;\n\n        case \"\\x7F\": // BACKSPACE\n          this.handleCursorErase(true);\n          break;\n\n        case \"\\t\": // TAB\n          if (this._autocompleteHandlers.length > 0) {\n            const inputFragment = this._input.substr(0, this._cursor);\n            const hasTailingSpace = hasTailingWhitespace(inputFragment);\n            const candidates = collectAutocompleteCandidates(\n              this._autocompleteHandlers,\n              inputFragment\n            );\n\n            // Sort candidates\n            candidates.sort();\n\n            // Depending on the number of candidates, we are handing them in\n            // a different way.\n            if (candidates.length === 0) {\n              // No candidates? Just add a space if there is none already\n              if (!hasTailingSpace) {\n                this.handleCursorInsert(\" \");\n              }\n            } else if (candidates.length === 1) {\n              // Just a single candidate? Complete\n              const lastToken = getLastToken(inputFragment);\n              this.handleCursorInsert(\n                candidates[0].substr(lastToken.length) + \" \"\n              );\n            } else if (candidates.length <= this.maxAutocompleteEntries) {\n              // If we are less than maximum auto-complete candidates, print\n              // them to the user and re-start prompt\n              this.printAndRestartPrompt(() => {\n                this.printWide(candidates);\n              });\n            } else {\n              // If we have more than maximum auto-complete candidates, print\n              // them only if the user acknowledges a warning\n              this.printAndRestartPrompt(() =>\n                this.readChar(\n                  `Display all ${candidates.length} possibilities? (y or n)`\n                ).then(yn => {\n                  if (yn == \"y\" || yn == \"Y\") {\n                    this.printWide(candidates);\n                  }\n                })\n              );\n            }\n          } else {\n            this.handleCursorInsert(\"    \");\n          }\n          break;\n\n        case \"\\x03\": // CTRL+C\n          this.setCursor(this._input.length);\n          this.term.write(\"^C\\r\\n\" + ((this._activePrompt || {}).prompt || \"\"));\n          this._input = \"\";\n          this._cursor = 0;\n          if (this.history) this.history.rewind();\n          break;\n        case \"\\x0B\": // Ctrl + k\n          this.term.clear();\n\n      }\n\n      // Handle visible characters\n    } else {\n      this.handleCursorInsert(data);\n    }\n  }\n}\n","import { parse } from \"shell-quote\";\n\n/**\n * Detects all the word boundaries on the given input\n */\nexport function wordBoundaries(input, leftSide = true) {\n  let match;\n  const words = [];\n  const rx = /\\w+/g;\n\n  while ((match = rx.exec(input))) {\n    if (leftSide) {\n      words.push(match.index);\n    } else {\n      words.push(match.index + match[0].length);\n    }\n  }\n\n  return words;\n}\n\n/**\n * The closest left (or right) word boundary of the given input at the\n * given offset.\n */\nexport function closestLeftBoundary(input, offset) {\n  const found = wordBoundaries(input, true)\n    .reverse()\n    .find(x => x < offset);\n  return found == null ? 0 : found;\n}\nexport function closestRightBoundary(input, offset) {\n  const found = wordBoundaries(input, false).find(x => x > offset);\n  return found == null ? input.length : found;\n}\n\n/**\n * Convert offset at the given input to col/row location\n *\n * This function is not optimized and practically emulates via brute-force\n * the navigation on the terminal, wrapping when they reach the column width.\n */\nexport function offsetToColRow(input, offset, maxCols) {\n  let row = 0,\n    col = 0;\n\n  for (let i = 0; i < offset; ++i) {\n    const chr = input.charAt(i);\n    if (chr === \"\\n\") {\n      col = 0;\n      row += 1;\n    } else {\n      col += 1;\n      if (col > maxCols) {\n        col = 0;\n        row += 1;\n      }\n    }\n  }\n\n  return { row, col };\n}\n\n/**\n * Counts the lines in the given input\n */\nexport function countLines(input, maxCols) {\n  return offsetToColRow(input, input.length, maxCols).row + 1;\n}\n\n/**\n * Checks if there is an incomplete input\n *\n * An incomplete input is considered:\n * - An input that contains unterminated single quotes\n * - An input that contains unterminated double quotes\n * - An input that ends with \"\\\"\n * - An input that has an incomplete boolean shell expression (&& and ||)\n * - An incomplete pipe expression (|)\n */\nexport function isIncompleteInput(input) {\n  // Empty input is not incomplete\n  if (input.trim() === \"\") {\n    return false;\n  }\n\n  // Check for dangling single-quote strings\n  if ((input.match(/'/g) || []).length % 2 !== 0) {\n    return true;\n  }\n  // Check for dangling double-quote strings\n  if ((input.match(/\"/g) || []).length % 2 !== 0) {\n    return true;\n  }\n  // Check for dangling boolean or pipe operations\n  if (\n    input\n      .split(/(\\|\\||\\||&&)/g)\n      .pop()\n      .trim() === \"\"\n  ) {\n    return true;\n  }\n  // Check for tailing slash\n  if (input.endsWith(\"\\\\\") && !input.endsWith(\"\\\\\\\\\")) {\n    return true;\n  }\n\n  return false;\n}\n\n/**\n * Returns true if the expression ends on a tailing whitespace\n */\nexport function hasTailingWhitespace(input) {\n  return input.match(/[^\\\\][ \\t]$/m) != null;\n}\n\n/**\n * Returns the last expression in the given input\n */\nexport function getLastToken(input) {\n  // Empty expressions\n  if (input.trim() === \"\") return \"\";\n  if (hasTailingWhitespace(input)) return \"\";\n\n  // Last token\n  const tokens = parse(input);\n  return tokens.pop() || \"\";\n}\n\n/**\n * Returns the auto-complete candidates for the given input\n */\nexport function collectAutocompleteCandidates(callbacks, input) {\n  const tokens = parse(input);\n  let index = tokens.length - 1;\n  let expr = tokens[index] || \"\";\n\n  // Empty expressions\n  if (input.trim() === \"\") {\n    index = 0;\n    expr = \"\";\n  } else if (hasTailingWhitespace(input)) {\n    // Expressions with danging space\n    index += 1;\n    expr = \"\";\n  }\n\n  // Collect all auto-complete candidates from the callbacks\n  const all = callbacks.reduce((candidates, { fn, args }) => {\n    try {\n      return candidates.concat(fn(index, tokens, ...args));\n    } catch (e) {\n      console.error(\"Auto-complete error:\", e);\n      return candidates;\n    }\n  }, []);\n\n  // Filter only the ones starting with the expression\n  return all.filter(txt => txt.startsWith(expr));\n}\n","/**\n * The history controller provides an ring-buffer\n */\nexport class HistoryController {\n  constructor(size) {\n    this.size = size;\n    this.entries = [];\n    this.cursor = 0;\n  }\n\n  /**\n   * Push an entry and maintain ring buffer size\n   */\n  push(entry) {\n    // Skip empty entries\n    if (entry.trim() === \"\") return;\n    // Skip duplicate entries\n    const lastEntry = this.entries[this.entries.length - 1];\n    if (entry === lastEntry) return;\n    // Keep track of entries\n    this.entries.push(entry);\n    if (this.entries.length > this.size) {\n      this.entries.pop(0);\n    }\n    this.cursor = this.entries.length;\n  }\n\n  /**\n   * Rewind history cursor on the last entry\n   */\n  rewind() {\n    this.cursor = this.entries.length;\n  }\n\n  /**\n   * Returns the previous entry\n   */\n  getPrevious() {\n    const idx = Math.max(0, this.cursor - 1);\n    this.cursor = idx;\n    return this.entries[idx];\n  }\n\n  /**\n   * Returns the next entry\n   */\n  getNext() {\n    const idx = Math.min(this.entries.length, this.cursor + 1);\n    this.cursor = idx;\n    return this.entries[idx];\n  }\n}\n"],"sourceRoot":""}