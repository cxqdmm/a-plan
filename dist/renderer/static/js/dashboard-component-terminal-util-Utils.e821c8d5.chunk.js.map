{"version":3,"sources":["renderer/pages/dashboard/component/terminal/util/Utils.js"],"names":["wordBoundaries","input","match","leftSide","arguments","length","undefined","words","rx","exec","push","index","closestLeftBoundary","offset","found","reverse","find","x","closestRightBoundary","offsetToColRow","maxCols","row","col","i","charAt","countLines","isIncompleteInput","trim","split","pop","endsWith","hasTailingWhitespace","getLastToken","parse","collectAutocompleteCandidates","callbacks","tokens","expr","reduce","candidates","_ref","fn","args","concat","apply","Object","_Users_mac_Documents_cxq_web_a_plan_node_modules_babel_runtime_helpers_esm_toConsumableArray__WEBPACK_IMPORTED_MODULE_0__","e","console","error","filter","txt","startsWith"],"mappings":"wlBAKO,SAASA,EAAeC,GAK7B,IALqD,IACjDC,EADgCC,IAAiBC,UAAAC,OAAA,QAAAC,IAAAF,UAAA,KAAAA,UAAA,GAE/CG,EAAQ,GACRC,EAAK,OAEHN,EAAQM,EAAGC,KAAKR,IAClBE,EACFI,EAAMG,KAAKR,EAAMS,OAEjBJ,EAAMG,KAAKR,EAAMS,MAAQT,EAAM,GAAGG,QAItC,OAAOE,EAOF,SAASK,EAAoBX,EAAOY,GACzC,IAAMC,EAAQd,EAAeC,GAAO,GACjCc,UACAC,KAAK,SAAAC,GAAC,OAAIA,EAAIJ,IACjB,OAAgB,MAATC,EAAgB,EAAIA,EAEtB,SAASI,EAAqBjB,EAAOY,GAC1C,IAAMC,EAAQd,EAAeC,GAAO,GAAOe,KAAK,SAAAC,GAAC,OAAIA,EAAIJ,IACzD,OAAgB,MAATC,EAAgBb,EAAMI,OAASS,EASjC,SAASK,EAAelB,EAAOY,EAAQO,GAI5C,IAHA,IAAIC,EAAM,EACRC,EAAM,EAECC,EAAI,EAAGA,EAAIV,IAAUU,EAAG,CAEnB,OADAtB,EAAMuB,OAAOD,IAEvBD,EAAM,EACND,GAAO,IAEPC,GAAO,GACGF,IACRE,EAAM,EACND,GAAO,GAKb,MAAO,CAAEA,MAAKC,OAMT,SAASG,EAAWxB,EAAOmB,GAChC,OAAOD,EAAelB,EAAOA,EAAMI,OAAQe,GAASC,IAAM,EAarD,SAASK,EAAkBzB,GAEhC,MAAqB,KAAjBA,EAAM0B,UAKL1B,EAAMC,MAAM,OAAS,IAAIG,OAAS,IAAM,KAIxCJ,EAAMC,MAAM,OAAS,IAAIG,OAAS,IAAM,IAQ7B,KAHdJ,EACG2B,MAAM,iBACNC,MACAF,WAKD1B,EAAM6B,SAAS,OAAU7B,EAAM6B,SAAS,YAUvC,SAASC,EAAqB9B,GACnC,OAAsC,MAA/BA,EAAMC,MAAM,gBAMd,SAAS8B,EAAa/B,GAE3B,MAAqB,KAAjBA,EAAM0B,OAAsB,GAC5BI,EAAqB9B,GAAe,GAGzBgC,gBAAMhC,GACP4B,OAAS,GAMlB,SAASK,EAA8BC,EAAWlC,GACvD,IAAMmC,EAASH,gBAAMhC,GACjBU,EAAQyB,EAAO/B,OAAS,EACxBgC,EAAOD,EAAOzB,IAAU,GAuB5B,MApBqB,KAAjBV,EAAM0B,QACRhB,EAAQ,EACR0B,EAAO,IACEN,EAAqB9B,KAE9BU,GAAS,EACT0B,EAAO,IAIGF,EAAUG,OAAO,SAACC,EAADC,GAA8B,IAAfC,EAAeD,EAAfC,GAAIC,EAAWF,EAAXE,KAC9C,IACE,OAAOH,EAAWI,OAAOF,EAAEG,WAAF,GAAGjC,EAAOyB,GAAVO,OAAAE,OAAAC,EAAA,EAAAD,CAAqBH,MAC9C,MAAOK,GAEP,OADAC,QAAQC,MAAM,uBAAwBF,GAC/BR,IAER,IAGQW,OAAO,SAAAC,GAAG,OAAIA,EAAIC,WAAWf","file":"static/js/dashboard-component-terminal-util-Utils.e821c8d5.chunk.js","sourcesContent":["import { parse } from \"shell-quote\";\n\n/**\n * Detects all the word boundaries on the given input\n */\nexport function wordBoundaries(input, leftSide = true) {\n  let match;\n  const words = [];\n  const rx = /\\w+/g;\n\n  while ((match = rx.exec(input))) {\n    if (leftSide) {\n      words.push(match.index);\n    } else {\n      words.push(match.index + match[0].length);\n    }\n  }\n\n  return words;\n}\n\n/**\n * The closest left (or right) word boundary of the given input at the\n * given offset.\n */\nexport function closestLeftBoundary(input, offset) {\n  const found = wordBoundaries(input, true)\n    .reverse()\n    .find(x => x < offset);\n  return found == null ? 0 : found;\n}\nexport function closestRightBoundary(input, offset) {\n  const found = wordBoundaries(input, false).find(x => x > offset);\n  return found == null ? input.length : found;\n}\n\n/**\n * Convert offset at the given input to col/row location\n *\n * This function is not optimized and practically emulates via brute-force\n * the navigation on the terminal, wrapping when they reach the column width.\n */\nexport function offsetToColRow(input, offset, maxCols) {\n  let row = 0,\n    col = 0;\n\n  for (let i = 0; i < offset; ++i) {\n    const chr = input.charAt(i);\n    if (chr === \"\\n\") {\n      col = 0;\n      row += 1;\n    } else {\n      col += 1;\n      if (col > maxCols) {\n        col = 0;\n        row += 1;\n      }\n    }\n  }\n\n  return { row, col };\n}\n\n/**\n * Counts the lines in the given input\n */\nexport function countLines(input, maxCols) {\n  return offsetToColRow(input, input.length, maxCols).row + 1;\n}\n\n/**\n * Checks if there is an incomplete input\n *\n * An incomplete input is considered:\n * - An input that contains unterminated single quotes\n * - An input that contains unterminated double quotes\n * - An input that ends with \"\\\"\n * - An input that has an incomplete boolean shell expression (&& and ||)\n * - An incomplete pipe expression (|)\n */\nexport function isIncompleteInput(input) {\n  // Empty input is not incomplete\n  if (input.trim() === \"\") {\n    return false;\n  }\n\n  // Check for dangling single-quote strings\n  if ((input.match(/'/g) || []).length % 2 !== 0) {\n    return true;\n  }\n  // Check for dangling double-quote strings\n  if ((input.match(/\"/g) || []).length % 2 !== 0) {\n    return true;\n  }\n  // Check for dangling boolean or pipe operations\n  if (\n    input\n      .split(/(\\|\\||\\||&&)/g)\n      .pop()\n      .trim() === \"\"\n  ) {\n    return true;\n  }\n  // Check for tailing slash\n  if (input.endsWith(\"\\\\\") && !input.endsWith(\"\\\\\\\\\")) {\n    return true;\n  }\n\n  return false;\n}\n\n/**\n * Returns true if the expression ends on a tailing whitespace\n */\nexport function hasTailingWhitespace(input) {\n  return input.match(/[^\\\\][ \\t]$/m) != null;\n}\n\n/**\n * Returns the last expression in the given input\n */\nexport function getLastToken(input) {\n  // Empty expressions\n  if (input.trim() === \"\") return \"\";\n  if (hasTailingWhitespace(input)) return \"\";\n\n  // Last token\n  const tokens = parse(input);\n  return tokens.pop() || \"\";\n}\n\n/**\n * Returns the auto-complete candidates for the given input\n */\nexport function collectAutocompleteCandidates(callbacks, input) {\n  const tokens = parse(input);\n  let index = tokens.length - 1;\n  let expr = tokens[index] || \"\";\n\n  // Empty expressions\n  if (input.trim() === \"\") {\n    index = 0;\n    expr = \"\";\n  } else if (hasTailingWhitespace(input)) {\n    // Expressions with danging space\n    index += 1;\n    expr = \"\";\n  }\n\n  // Collect all auto-complete candidates from the callbacks\n  const all = callbacks.reduce((candidates, { fn, args }) => {\n    try {\n      return candidates.concat(fn(index, tokens, ...args));\n    } catch (e) {\n      console.error(\"Auto-complete error:\", e);\n      return candidates;\n    }\n  }, []);\n\n  // Filter only the ones starting with the expression\n  return all.filter(txt => txt.startsWith(expr));\n}\n"],"sourceRoot":""}